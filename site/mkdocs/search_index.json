{
    "docs": [
        {
            "location": "/",
            "text": "Background\n\n\nPer agreement, a client referred to Operation ID - a ministry of Main Street Ministries - by a partner agency must present a referral letter provided by\nthe agency to be eligible for identification services. The Electronic Referral System for Operation ID (Eref) is designed to support the generation of\nreferral letters by partner agencies in a way which will both simplify the process of serving clients and enhance record keeping by agencies and\nOperation ID alike. Eref will be available as a password protected website to all subscribing partner agencies. This document describes the design and\nimplementation of Eref. The Infrastructure tab describes how project Eref is maintained on a desktop host and how it is deployed to the .NET hosting\nservice AppHarbor.\n\n\nUsers\n\n\nEref is a role-based system. Each registered user of Eref will be assigned a user role by the Eref administrator. The role that a user is in will determine the Eref features available to the user.\n\n\nMost users of Eref will be members of agencies referring clients to Operation ID and will be in the role of Client Advocate. In the role of Client\nAdvocate, a user will be able to refer new clients by generating referral letters and to review identification services requested for existing clients.\nA Client Advocate will only be able to refer/review clients being assisted through his/her agency.\n\n\nUsers of Eref registered as members of Main Street Ministries will be assigned a role that will enable them to review clients referred by all partner\nagencies. They will also be able to generate a new referral letter for an agency client in case the services requested by a client change on the day \nthe client appears at Operation ID.\n\n\nThe remainder of this document will focus on how Eref will be used by a user in the role of Client Advocate.\n\n\nThe Client Advocate\n\n\nA user in the role of Client Advocate has the responsibility of interviewing prospective Operation ID clients to determine the identification services\nthey need and to determine the documents they currently have in support of the services they seek. The services provided by Operation ID include\n\n\n\n\nBirth Certificate\n\n\nTexas ID\n\n\nTexas DL\n\n\n\n\nThere are several other services that are occasionally requested and these will be discussed below.\n\n\nOperation ID will provide vouchers for requested services to enable clients to pay for them. It is a client\u2019s responsibility to obtain the identification\ndocument by presenting a voucher and supporting documents to the appropriate agency. In the case of an out-of-state birth certificate, Operation ID will\ncomplete the necessary paperwork and submit it together with a voucher to the appropriate out-of-state agency.\n\n\nIn addition to registering a client through Eref, a Client Advocate may also register dependents of a client together with the services requested for each\ndependent.\n\n\nWith the click of a button, a Client Advocate user will generate a referral letter summarizing the services requested by a client (plus any dependents)\ntogether with the documents available in support of the requested services.",
            "title": "Background"
        },
        {
            "location": "/#background",
            "text": "Per agreement, a client referred to Operation ID - a ministry of Main Street Ministries - by a partner agency must present a referral letter provided by\nthe agency to be eligible for identification services. The Electronic Referral System for Operation ID (Eref) is designed to support the generation of\nreferral letters by partner agencies in a way which will both simplify the process of serving clients and enhance record keeping by agencies and\nOperation ID alike. Eref will be available as a password protected website to all subscribing partner agencies. This document describes the design and\nimplementation of Eref. The Infrastructure tab describes how project Eref is maintained on a desktop host and how it is deployed to the .NET hosting\nservice AppHarbor.",
            "title": "Background"
        },
        {
            "location": "/#users",
            "text": "Eref is a role-based system. Each registered user of Eref will be assigned a user role by the Eref administrator. The role that a user is in will determine the Eref features available to the user.  Most users of Eref will be members of agencies referring clients to Operation ID and will be in the role of Client Advocate. In the role of Client\nAdvocate, a user will be able to refer new clients by generating referral letters and to review identification services requested for existing clients.\nA Client Advocate will only be able to refer/review clients being assisted through his/her agency.  Users of Eref registered as members of Main Street Ministries will be assigned a role that will enable them to review clients referred by all partner\nagencies. They will also be able to generate a new referral letter for an agency client in case the services requested by a client change on the day \nthe client appears at Operation ID.  The remainder of this document will focus on how Eref will be used by a user in the role of Client Advocate.",
            "title": "Users"
        },
        {
            "location": "/#the-client-advocate",
            "text": "A user in the role of Client Advocate has the responsibility of interviewing prospective Operation ID clients to determine the identification services\nthey need and to determine the documents they currently have in support of the services they seek. The services provided by Operation ID include   Birth Certificate  Texas ID  Texas DL   There are several other services that are occasionally requested and these will be discussed below.  Operation ID will provide vouchers for requested services to enable clients to pay for them. It is a client\u2019s responsibility to obtain the identification\ndocument by presenting a voucher and supporting documents to the appropriate agency. In the case of an out-of-state birth certificate, Operation ID will\ncomplete the necessary paperwork and submit it together with a voucher to the appropriate out-of-state agency.  In addition to registering a client through Eref, a Client Advocate may also register dependents of a client together with the services requested for each\ndependent.  With the click of a button, a Client Advocate user will generate a referral letter summarizing the services requested by a client (plus any dependents)\ntogether with the documents available in support of the requested services.",
            "title": "The Client Advocate"
        },
        {
            "location": "/infrastructure/",
            "text": "Infrastructure\n\n\nThe infrastructure of project Eref refers to the tools and technologies used to develop Eref, exclusive of the implementation itself. This\nsection will be useful to a developer wanting to maintain and further develop Eref.  It describes both the desktop development environment and the\nAppHarbor deployment environment for application Eref.\n\n\nHosting Environments\n\n\nThere are 3 hosting environments for Eref: desktop, staging and production. They differ in the database connection string used by each.\nThe connection string is configured as the value of variable SQLSERVER_CONNECTION_STRING in the \n<appSettings>\n section of\nWeb.config. The static value configured there is used by the desktop environment. The static value is overwritten by injection (at AppHarbor)\nwhen Eref is deployed to create either a staging or production release. The transformation files Web.Staging.config and Web.Release.config\nplay a role in these deployments. The staging deployment at AppHarbor has its Environment variable set to Staging to force Web.Staging.config\nto be used upon deployment. This is done in the Settings section of the deployed application. The production deployment at AppHarbor has its\nEnvironment variable set to Release by default. This causes Web.Release.config to be used upon deployment.\n\n\nVisual Studio Project\n\n\nThe Visual Studio 2015 (Community Edition) project representing application Eref was developed using an ASP.NET Identity 2.0 sample project developed by\nSyed Shanu as a starting point. The project is described in the \nexcellent CodeProject article ASP.NET MVC Security and Creating User Role\n\n\nThe sample project uses the Visual Studio MVC5 project template and makes use of Katana OWIN middleware for user authentication. The use of Katana is built into the ASP.NET Identity 2.0 provider used by the project template, as is explained in the CodeProject article.\n\n\nThe Eref application used the sample project as a starting point. The sample project was downloaded to the folder \nC:/Projects/Eref\n on the desktop\nhost\u2019s hard drive and the solution file was renamed to Eref.sln.\n\n\nThe Properties page of the Visual Studio project sets the Local IIS as the server and sets\n\n\n http://localhost/Eref\n\n\n\nas the Project Url. This create an application called Eref under the Default Web Site in IIS and enables project Eref to be run in a desktop version\nof IIS under this Url. See the section on configuring IIS below.\n\n\nThe Eref project should be ported to newer versions of Visual Studio as they become available. Visual Studio 2017 is already avaialable and a port\nshould be performed soon.\n\n\nEntity Framework Code First\n\n\nSince project Eref was just a renaming of the sample project, it was ready to run after the connection string had been established. When it ran for the\nfirst time the SuperAdmin user, sa, was automatically created by method Startup.Configuration on file Eref/Startup.cs. (The class Startup on file\nStartup.cs is required by the OWIN specification.) The automatic creation of user sa caused the ASP.NET Identity tables to be created in the ErefDB\ndatabase. After these tables were created, file Eref/DataContexts/IdentityDb.cs was created. This file contains a pair of classes which serve to connect \nthe data context to the database via the connection string ErefConnection. (See the Database tab for details about the connection string, which must\nbe obtained and configured in Web.config first!)\n\n\nNext, the first of the two data contexts used by project Eref, the IdentityDb data context, was initialized in the Visual Studio project by executing\nthe command \n\n\nPM> Enable-Migrations -ContextTypeName Eref.DataContexts.IdentityDb -MigrationsDirectory DataContexts\\IdentityMigrations\n\n\n\nin the Package Manager Console, followed by executing the command\n\n\nPM> add-migration -ConfigurationTypeName Eref.DataContexts.IdentityMigrations.Configuration \"InitialCreate\"\n\n\n\nDefining class IdentityDb and executing the above two commands is the standard way to begin Entity Framework Code First development with respect to a\ndata context. Executing the second command automatically created the file DataContexts/IdentityMigrations/\ntimestamp\n_IntialCreate.cs. It is worth\nstudying this file to see how the various tables of AspNet Identity are defined.\n\n\nAfter the IdentityDb data context was created, it was time to create the ReferrralsDB data context. The file Eref/DataContexts/ReferralsDB.cs was\ncreated for this purpose. Like file IdentityDb.cs, this file connects the ReferralsDB data context to the database via the ErefConnection string.\n\n\nThe file defines class ReferralsDB whose initial definition contained the single DbSet called Agencies, corresponding to the desired Agencies table \nin the ErefDB database. The declaration of the DbSet in class ReferralsDB was\n\n\npublic DbSet<Agency> Agencies { get; set}\n\n\n\nindicating that the columns of the database table Agencies would be taken from a class called Agency. \n\n\nClass Agency is an example of an \nentity class\n, a class corresponding to a database table. The definition of entity classes is the reason\nfor the technology name Entity Framework Code First. There are several entity classes in project Eref and\neach entity class is defined in a Class Library subproject of the Visual Studio Eref solution called ErefEntities.\n\n\nTo cause the Agencies table to be built, the following three commands were executed in the Package Manager Console.\n\n\nPM> Enable-Migrations -ContextTypeName Eref.DataContexts.ReferralsDB -MigrationsDirectory DataContexts\\AgencyMigrations\n\nPM> add-migration -ConfigurationTypeName Eref.DataContexts.ReferralMigrations.Configuration \"InitialCreate\"\n\n\n\nand\n\n\n PM> update-database -ConfigurationTypeName Eref.DataContexts.ReferralMigrations.Configuration\n\n\n\nThe last of these commands is the one which creates table Agencies in the ErefDB. It does so by executing the Up method in file\nDataContexts/ReferralMigrations/\ntimestamp\n_InitialCreate.cs, which was automatically created by the second command. (It was not necessary to execute an \nupdate-database command for the IdentityMigrations data context because the tables described in IdentityMigrations/\ntimestamp\n_InitialCreate.cs were\ncreated automatically by ASP.NET Identity when the SuperAdmin user, sa, was registered.)\n\n\nEach additional database change requires a pair of commands: an add-migration command followed by an update-database command. \nExecuting an add-migration command creates a .cs file in the folder associated with the ConfigurationTypeName. Study this .cs file before executing the\nupdate-database command. If the database changes indicated in the .cs file are not correct, simply delete the .cs file before running the \nupdate-database command and then try again.\n\n\nConfiguring IIS\n\n\nDevelopment of the Eref application was performed under IIS on the localhost machine. This was done so that the development environment would match the deployment environment at AppHarbor as closely as possible.\n\n\nThe localhost application server, Internet Information Services (IIS), was not pre-installed on the localhost; however, it is part of the operating system that can easily be activated. To activate IIS, go to the Programs section of the Control Panel and turn on the IIS feature:\n\n\nPrograms > Programs and Features > Turn Windows features on or off > Internet Information Services\n\n\n\nAfter checking this box, expand it by clicking the plus sign (+) next to it and go to the section\n\n\nWorld Wide Web Services > Application Development Features\n\n\n\nIn this section, check the checkboxes for\n\n\n    ASP\n    ASP.NET 3.5\n    ASP.NET 4.6\n\n\n\nif they are not already checked. This will cause additional Application Pools to be made available to IIS. \n\n\nThe Eref application is installed as an application under the Default Web Site in IIS as described in the section describing the Visual Studio Project.\nThe Basic Settings dialog box for application Eref (accessible from the Actions pane of IIS), will give the physical path to the folder containing the \nsource code as\n\n\nC:\\Projects\\Eref\\Eref\n\n\n\nThe folder above this (\nC:\\Projects\\Eref\n) is the folder containing the project solution file, Eref.sln. Do not change it!\nApplication Eref must be configured to use the application pool .NET v4.5. in the Basic Settings dialog box. (This application pool became \navailable by enabling the features described above.)\n\n\nFinally, change the application identity of the selected application pool (.NET v4.5) to NetworkService. To do this, highlight Application Pools on the\nIIS Connections panel. This will cause the available application pools to appear in the IIS body panel. Highlight the .NET v4.5 application pool and\nthen select Set Application Pool Defaults\u2026 to display a dialog box that will enable you to change the identity of the application pool. The dialog box\nis reachable either from the context menu of the highlighted application pool (under right mouse click) or from the Actions panel on the right of the\nIIS display.\n\n\nThe dialog box contains a section labeled Process Model which contains an entry labeled Identity. Selecting the Identity entry adds an ellipsis next to\nthe bold ApplicationPoolIdentity. Selecting the ellipsis brings up a dialog box with the pre-selected radio button Built-in account. Select\nNetworkService from the dropdown menu associated with this radio button. After approving this selection, the Identity column of the application pool\n.NET v4.5 will show NetworkService. This is important! The next section shows how to create user NetworkService in the database.\n\n\nSQL Server Express\n\n\nThe desktop version of Eref makes use of a SQL Server Express to store information about referrals. \nInstalling SQL Server 2016 Management Studio (SSMS) from Microsoft causes SQL Server Express to be installed as well. The download is large and the\ninstallation from the download takes some time. Just accept all the defaults.\n\n\nThe SQL Server Express database for Eref was created by executing the SQL query\n\n\ncreate database ErefDB\n\n\n\nexecuted inside of SQL Server Management Studio. With this database selected in SSMS, there are two SQL queries that need to be executed to enable IIS\nto talk to SQL Server. The first query is\n\n\n   CREATE USER [NT AUTHORITY\\NETWORK SERVICE]\n   FOR LOGIN [NT AUTHORITY\\NETWORK SERVICE]\n   WITH DEFAULT_SCHEMA = dbo;\n\n\n\nThis query creates the database user NT AUTHORITY\\NETWORK SERVICE. The second query is\n\n\n  EXEC sp_addrolemember 'db_owner', 'NT AUTHORITY\\NETWORK SERVICE'\n\n\n\nThis query grants user NT AUTHORITY\\NETWORK SERVICE the necessary permissions to communicate with IIS. These same two queries also need to be executed\nin the AppHarbor database to prepare it to communicate with IIS. See below for information about the AppHarbor deployment of Eref.\n\n\nGit for Windows\n\n\nVisual Studio 2015 (Community Edition) comes with built-in support for GitHub. A new project can be added to Git source control on the desktop by simply\nselecting \nAdd to Source Control\n from the context menu of the Solution file in the Solution Explorer. Once a project is under Git source control it can \nbe added to a remote GitHub repository by using tools available through Visual Studio. However, a technique preferred by many developers is to use \nGit\nfor Windows\n. Git for Windows provides a BASH shell interface to GitHub which uses the same set of commands\navailable at GitHub itself. Git for Windows integrates with Windows Explorer to allow a BASH shell to be opened on a project that has been added to a\ndesktop Git repository. Simply point Windows Explorer at the folder containing the project solution file and select \nGit BASH Here\n from the context\nmenu of the folder to open a Git for Windows BASH shell. Then execute Git commands from this shell window. Git for Windows also offers Git GUI, a\ngraphical version of most Git command line functions. To open Git GUI simply select Git GUI Here from Windows Explorer.\n\n\nGitHub\n\n\nA Main Street Ministries (MSM) account has been established at github.com with credentials:\n\n\nUser name: msmapricot\nEmail: apricot@msmhouston.org\nPassword: <secret>\n\n\n\nGit for Windows is used to create a remote to save to the MSM account. The remote is created in the Git BASH shell by opening the shell on the folder which contains the Eref.sln file (folder \nC:/Projects/Eref\n) and issuing the command\n\n\ngit remote add origin https://github.com/msmapricot/eref.git\n\n\n\nCreating this remote only needs to be done once, because Git for Windows stores the remote in Visual Studio. To see this, go to the Team Explorer tab of\nthe Visual Studio Solution Explorer and select Settings from the Welcome to GitHub for Visual Studio menu. Then select Repository Settings and find the\nremote called origin under the Remotes section.\n\n\nAppHarbor\n\n\nAppHarbor (appharbor.com) is a Platform as a Service Provider which uses Amazon Web Services infrastructure for hosting applications and Git as a \nversioning tool. When an application is defined at AppHarbor, a Git repository is created to manage versions of the application's deployment.\nThe Eref application is defined as an application at AppHarbor to create the production repository of the desktop application. The staging version\nof the desktop application is defined by a repository called SEref. The Eref repository at AppHarbor is maintained at the Catmaran piad subscription\nlevel and the SEref repository is maintained at the free Canoe subscription level.\n\n\nA Main Street Ministries (MSM) account has been created at AppHarbor for deployment of the application. The credentials for this account are:\n\n\nUser name: msmapricot\nEmail: apricot@msmhouston.org\nPassword: <secret>\n\n\n\nOnly user msmapricot can deploy directly to an application in the MSM account. Any other user needing to deploy to an application in the MSM account must\nbe declared a collaborator on this application. A collaborator is a user associated with a different account established at AppHarbor. For example, my\npersonal account at AppHarbor uses the user name tmhsplb. The user name tmhsplb has been added as a collaborator on the Eref application, thereby\nallowing me to deploy to this application.\n\n\nThe remote configured for Eref in Visual Studio is:\n\n\nhttps://msmapricot@appharbor.com/eref.git\n\n\n\nThis remote is configured from a Windows Git BASH shell by the command\n\n\ngit remote add eref https://msmapricot@appharbor.com/eref.git\n\n\n\nAfter the remote is configured in the Git BASH shell, issuing the command\n\n\ngit push eref master\n\n\n\nwill deploy the master branch of Eref to AppHarbor as application Eref.\n\n\nIf you reset your password at AppHarbor, the 'git push' command will no longer work from the Git BASH shell. You need to have git prompt you for your\nnew password. To do this on a Windows 10 machine, go to\n\n\nControl Panel > User Accounts > Credential Manager > Windows Credentials\n\n\nand remove the AppHarbor entry under Generic Credentials. The next time you push, you will be prompted for your repository password.\n\n\nAn application such as SEref deployed using the free Canoe subscription level at AppHarbor has limitations that make it unsuitable for production\nuse. Under the Canoe subscription, the IIS application pool of application SEref has a 20 minute timeout, which forces SEref to spin up its resources\nagain after each 20 minutes of idle time.\n\n\nThe URL of the Canoe version is\n\n\nhttps://eref.apphb.com\n\n\n\nThe free Yocto version of SQL Server is used as an add-on to the Eref deployment. The Yocto version is free but has a limit of 20MB of storage space,\nwhich is adequate for development purposes.  \n\n\nThe remote configured for SEref in Visual Studio is:\n\n\nhttps://msmapricot@appharbor.com/seref.git\n\n\n\nThis remote is configured from a Windows Git BASH shell by the command\n\n\ngit remote add seref https://msmapricot@appharbor.com/seref.git\n\n\n\nAfter the remote is configured in the Git BASH shell, issuing the command\n\n\ngit push seref master\n\n\n\nwill deploy the master branch of Eref to AppHarbor as application SEref.\n\n\nThe production version of application Eref was created by changing the subsription of application Eref from Canoe to Catamaran. The URL of the production\nversion is still https://eref.apphb.com.\n\n\nIt is possible to use AppHarbor to generate a custom domain name for an application, but this has not been done for the Eref application. The SQL \nServer of the production version of Eref was upgraded from the free Yocto version to the paid uses the Nano version which has a 10GB storage limit. \nThe staging application SEref uses the free Canoe service and the free Canoe version of SQL Server.\n\n\njqGrid\n\n\nAlmost every page of the Eref application features a grid produced by the jQuery jqGrid component. It was installed into the Eref project by using\nthe Package Manager command:\n\n\nPM> Install-Package Triand.jqGrid -Version 4.6.0\n\n\n\nThere is a collection of \njqGrid Demos\n that was very helpful during the development of Eref.\n\n\nlog4net\n\n\nApplication logging is handled by Version 2.0.8 of log4net by the Apache Software Foundation. This package was installed using the Visual Studio NuGet\npackage manager. The application log for project Eref is maintained as a database table as described in \n\nthis article\n describing the AdoNetAppender for log4net. The article includes a script\nfor creating table Log (renamed AppLog in application Eref). The script must be executed as a query in SSMS to create table AppLog in the database.\n\n\nThe application log is configured by the connection string named ErefConnectionString on Web.config. The value of this connection string is overwritten\nwhen the application is deployed to AppHarbor. See the Connection String section of the Database tab.\n\n\nELMAH\n\n\nUnhandled application errors are caught by ELMAH. Version 2.1.2 of Elamh.Mvc was installed in project Eref by using the Visual Studio NuGet package\nmanager. To see ELMAH in action, modify the URL in the browser address bar to, for example,\n\n\neref.apphb.com/Admin/Foo\n\n\n\nThis will generate an unhandled error because the MVC routing system will not be able to resolve the URL. Then go to\n\n\neref.apphb.com/elmah.axd\n\n\n\nto see that this error has been caught by ELMAH.\n\n\nInstallation of the Elmah.Mvc package adds the necessary DLL's and makes the necessary changes to Web.config to configure ELMAH for use. By default\nELMAH will write to a database table called ELMAH_Error. The DDL Script definition of this table is found in a \n\nseparate download\n. Download the DDL Script for MS SQL Server from the referenced web page. The script is a .SQL\nfile which may be executed as a query inside SSMS to create table ELMAH_Error.\n\n\nThe ELMAH log is configured by the connection string named ErefConnectionString on Web.config. The value of this connection string is overwritten\nwhen the application is deployed to AppHarbor. See the Connection String section of the Database tab.\n\n\nGoogle Maps\n\n\nThe referral letter generated by Eref includes a static Google Map showing the location of Main Street Ministries. A new copy of this map is generated\neach time a referral letter is requested. The map is generated using the Google Maps static map API. The key for this API is stored in the\n\n<appSettings>\n section of Web.config under the name GmapKey.\n\n\nMkDocs\n\n\nThis document was created using MkDocs as was the \nMkDocs website\n itself. MkDocs was installed following the guide\non \nthis page\n. An MkDocs document is a static website and can hosted by\nany service that supports static sites. This MkDocs document is hosted by \nGitHub Pages\n. The \nBrackets\n\nopen sourece text editor was used to develop the document on the desktop. An MkDocs document uses HTML Markdown for a desktop development version of a\ndocument. GitHub provides a \ncheatsheet for Markdown syntax\n.\n\n\nMkDocs provides a built-in preview server which allows the development version to be viewed in a desktop browser at \n\n\nhttp://127.0.0.1:8000\n\n\n\nWhen it is time to publish a version of a document, in a Git BASH shell opened on the folder containing the mkdocs.yml file, issue the command\n\n\nmkdocs build\n\n\n\nto expand the Markdown version of the document into an HTML version into the /site folder. After this define a remote called origin for the document:\n\n\ngit remote add origin https://github.com/msmapricot/erefdoc\n\n\n\nThis command references the pre-created GitHub repository erefdoc. The remote only  needs to be defined once. It will be remembered by the \nGit BASH shell. \n\n\nIn the shell issue the following commands:\n\n\ngit add -A\n\ngit commit -a -m 'Comment on new version of eref document'\n\ngit push --set-upstream origin master\n\n\n\nThis will push the master branch of the document to the repository identified by the remote called origin. To view the published document go to:\n\n\nhttps://msmapricot.github.io/erefdoc/site\n\n\n\nIt will take several minutes before the changes are available.",
            "title": "Infrastructure"
        },
        {
            "location": "/infrastructure/#infrastructure",
            "text": "The infrastructure of project Eref refers to the tools and technologies used to develop Eref, exclusive of the implementation itself. This\nsection will be useful to a developer wanting to maintain and further develop Eref.  It describes both the desktop development environment and the\nAppHarbor deployment environment for application Eref.",
            "title": "Infrastructure"
        },
        {
            "location": "/infrastructure/#hosting-environments",
            "text": "There are 3 hosting environments for Eref: desktop, staging and production. They differ in the database connection string used by each.\nThe connection string is configured as the value of variable SQLSERVER_CONNECTION_STRING in the  <appSettings>  section of\nWeb.config. The static value configured there is used by the desktop environment. The static value is overwritten by injection (at AppHarbor)\nwhen Eref is deployed to create either a staging or production release. The transformation files Web.Staging.config and Web.Release.config\nplay a role in these deployments. The staging deployment at AppHarbor has its Environment variable set to Staging to force Web.Staging.config\nto be used upon deployment. This is done in the Settings section of the deployed application. The production deployment at AppHarbor has its\nEnvironment variable set to Release by default. This causes Web.Release.config to be used upon deployment.",
            "title": "Hosting Environments"
        },
        {
            "location": "/infrastructure/#visual-studio-project",
            "text": "The Visual Studio 2015 (Community Edition) project representing application Eref was developed using an ASP.NET Identity 2.0 sample project developed by\nSyed Shanu as a starting point. The project is described in the  excellent CodeProject article ASP.NET MVC Security and Creating User Role  The sample project uses the Visual Studio MVC5 project template and makes use of Katana OWIN middleware for user authentication. The use of Katana is built into the ASP.NET Identity 2.0 provider used by the project template, as is explained in the CodeProject article.  The Eref application used the sample project as a starting point. The sample project was downloaded to the folder  C:/Projects/Eref  on the desktop\nhost\u2019s hard drive and the solution file was renamed to Eref.sln.  The Properties page of the Visual Studio project sets the Local IIS as the server and sets   http://localhost/Eref  as the Project Url. This create an application called Eref under the Default Web Site in IIS and enables project Eref to be run in a desktop version\nof IIS under this Url. See the section on configuring IIS below.  The Eref project should be ported to newer versions of Visual Studio as they become available. Visual Studio 2017 is already avaialable and a port\nshould be performed soon.",
            "title": "Visual Studio Project"
        },
        {
            "location": "/infrastructure/#entity-framework-code-first",
            "text": "Since project Eref was just a renaming of the sample project, it was ready to run after the connection string had been established. When it ran for the\nfirst time the SuperAdmin user, sa, was automatically created by method Startup.Configuration on file Eref/Startup.cs. (The class Startup on file\nStartup.cs is required by the OWIN specification.) The automatic creation of user sa caused the ASP.NET Identity tables to be created in the ErefDB\ndatabase. After these tables were created, file Eref/DataContexts/IdentityDb.cs was created. This file contains a pair of classes which serve to connect \nthe data context to the database via the connection string ErefConnection. (See the Database tab for details about the connection string, which must\nbe obtained and configured in Web.config first!)  Next, the first of the two data contexts used by project Eref, the IdentityDb data context, was initialized in the Visual Studio project by executing\nthe command   PM> Enable-Migrations -ContextTypeName Eref.DataContexts.IdentityDb -MigrationsDirectory DataContexts\\IdentityMigrations  in the Package Manager Console, followed by executing the command  PM> add-migration -ConfigurationTypeName Eref.DataContexts.IdentityMigrations.Configuration \"InitialCreate\"  Defining class IdentityDb and executing the above two commands is the standard way to begin Entity Framework Code First development with respect to a\ndata context. Executing the second command automatically created the file DataContexts/IdentityMigrations/ timestamp _IntialCreate.cs. It is worth\nstudying this file to see how the various tables of AspNet Identity are defined.  After the IdentityDb data context was created, it was time to create the ReferrralsDB data context. The file Eref/DataContexts/ReferralsDB.cs was\ncreated for this purpose. Like file IdentityDb.cs, this file connects the ReferralsDB data context to the database via the ErefConnection string.  The file defines class ReferralsDB whose initial definition contained the single DbSet called Agencies, corresponding to the desired Agencies table \nin the ErefDB database. The declaration of the DbSet in class ReferralsDB was  public DbSet<Agency> Agencies { get; set}  indicating that the columns of the database table Agencies would be taken from a class called Agency.   Class Agency is an example of an  entity class , a class corresponding to a database table. The definition of entity classes is the reason\nfor the technology name Entity Framework Code First. There are several entity classes in project Eref and\neach entity class is defined in a Class Library subproject of the Visual Studio Eref solution called ErefEntities.  To cause the Agencies table to be built, the following three commands were executed in the Package Manager Console.  PM> Enable-Migrations -ContextTypeName Eref.DataContexts.ReferralsDB -MigrationsDirectory DataContexts\\AgencyMigrations\n\nPM> add-migration -ConfigurationTypeName Eref.DataContexts.ReferralMigrations.Configuration \"InitialCreate\"  and   PM> update-database -ConfigurationTypeName Eref.DataContexts.ReferralMigrations.Configuration  The last of these commands is the one which creates table Agencies in the ErefDB. It does so by executing the Up method in file\nDataContexts/ReferralMigrations/ timestamp _InitialCreate.cs, which was automatically created by the second command. (It was not necessary to execute an \nupdate-database command for the IdentityMigrations data context because the tables described in IdentityMigrations/ timestamp _InitialCreate.cs were\ncreated automatically by ASP.NET Identity when the SuperAdmin user, sa, was registered.)  Each additional database change requires a pair of commands: an add-migration command followed by an update-database command. \nExecuting an add-migration command creates a .cs file in the folder associated with the ConfigurationTypeName. Study this .cs file before executing the\nupdate-database command. If the database changes indicated in the .cs file are not correct, simply delete the .cs file before running the \nupdate-database command and then try again.",
            "title": "Entity Framework Code First"
        },
        {
            "location": "/infrastructure/#configuring-iis",
            "text": "Development of the Eref application was performed under IIS on the localhost machine. This was done so that the development environment would match the deployment environment at AppHarbor as closely as possible.  The localhost application server, Internet Information Services (IIS), was not pre-installed on the localhost; however, it is part of the operating system that can easily be activated. To activate IIS, go to the Programs section of the Control Panel and turn on the IIS feature:  Programs > Programs and Features > Turn Windows features on or off > Internet Information Services  After checking this box, expand it by clicking the plus sign (+) next to it and go to the section  World Wide Web Services > Application Development Features  In this section, check the checkboxes for      ASP\n    ASP.NET 3.5\n    ASP.NET 4.6  if they are not already checked. This will cause additional Application Pools to be made available to IIS.   The Eref application is installed as an application under the Default Web Site in IIS as described in the section describing the Visual Studio Project.\nThe Basic Settings dialog box for application Eref (accessible from the Actions pane of IIS), will give the physical path to the folder containing the \nsource code as  C:\\Projects\\Eref\\Eref  The folder above this ( C:\\Projects\\Eref ) is the folder containing the project solution file, Eref.sln. Do not change it!\nApplication Eref must be configured to use the application pool .NET v4.5. in the Basic Settings dialog box. (This application pool became \navailable by enabling the features described above.)  Finally, change the application identity of the selected application pool (.NET v4.5) to NetworkService. To do this, highlight Application Pools on the\nIIS Connections panel. This will cause the available application pools to appear in the IIS body panel. Highlight the .NET v4.5 application pool and\nthen select Set Application Pool Defaults\u2026 to display a dialog box that will enable you to change the identity of the application pool. The dialog box\nis reachable either from the context menu of the highlighted application pool (under right mouse click) or from the Actions panel on the right of the\nIIS display.  The dialog box contains a section labeled Process Model which contains an entry labeled Identity. Selecting the Identity entry adds an ellipsis next to\nthe bold ApplicationPoolIdentity. Selecting the ellipsis brings up a dialog box with the pre-selected radio button Built-in account. Select\nNetworkService from the dropdown menu associated with this radio button. After approving this selection, the Identity column of the application pool\n.NET v4.5 will show NetworkService. This is important! The next section shows how to create user NetworkService in the database.",
            "title": "Configuring IIS"
        },
        {
            "location": "/infrastructure/#sql-server-express",
            "text": "The desktop version of Eref makes use of a SQL Server Express to store information about referrals. \nInstalling SQL Server 2016 Management Studio (SSMS) from Microsoft causes SQL Server Express to be installed as well. The download is large and the\ninstallation from the download takes some time. Just accept all the defaults.  The SQL Server Express database for Eref was created by executing the SQL query  create database ErefDB  executed inside of SQL Server Management Studio. With this database selected in SSMS, there are two SQL queries that need to be executed to enable IIS\nto talk to SQL Server. The first query is     CREATE USER [NT AUTHORITY\\NETWORK SERVICE]\n   FOR LOGIN [NT AUTHORITY\\NETWORK SERVICE]\n   WITH DEFAULT_SCHEMA = dbo;  This query creates the database user NT AUTHORITY\\NETWORK SERVICE. The second query is    EXEC sp_addrolemember 'db_owner', 'NT AUTHORITY\\NETWORK SERVICE'  This query grants user NT AUTHORITY\\NETWORK SERVICE the necessary permissions to communicate with IIS. These same two queries also need to be executed\nin the AppHarbor database to prepare it to communicate with IIS. See below for information about the AppHarbor deployment of Eref.",
            "title": "SQL Server Express"
        },
        {
            "location": "/infrastructure/#git-for-windows",
            "text": "Visual Studio 2015 (Community Edition) comes with built-in support for GitHub. A new project can be added to Git source control on the desktop by simply\nselecting  Add to Source Control  from the context menu of the Solution file in the Solution Explorer. Once a project is under Git source control it can \nbe added to a remote GitHub repository by using tools available through Visual Studio. However, a technique preferred by many developers is to use  Git\nfor Windows . Git for Windows provides a BASH shell interface to GitHub which uses the same set of commands\navailable at GitHub itself. Git for Windows integrates with Windows Explorer to allow a BASH shell to be opened on a project that has been added to a\ndesktop Git repository. Simply point Windows Explorer at the folder containing the project solution file and select  Git BASH Here  from the context\nmenu of the folder to open a Git for Windows BASH shell. Then execute Git commands from this shell window. Git for Windows also offers Git GUI, a\ngraphical version of most Git command line functions. To open Git GUI simply select Git GUI Here from Windows Explorer.",
            "title": "Git for Windows"
        },
        {
            "location": "/infrastructure/#github",
            "text": "A Main Street Ministries (MSM) account has been established at github.com with credentials:  User name: msmapricot\nEmail: apricot@msmhouston.org\nPassword: <secret>  Git for Windows is used to create a remote to save to the MSM account. The remote is created in the Git BASH shell by opening the shell on the folder which contains the Eref.sln file (folder  C:/Projects/Eref ) and issuing the command  git remote add origin https://github.com/msmapricot/eref.git  Creating this remote only needs to be done once, because Git for Windows stores the remote in Visual Studio. To see this, go to the Team Explorer tab of\nthe Visual Studio Solution Explorer and select Settings from the Welcome to GitHub for Visual Studio menu. Then select Repository Settings and find the\nremote called origin under the Remotes section.",
            "title": "GitHub"
        },
        {
            "location": "/infrastructure/#appharbor",
            "text": "AppHarbor (appharbor.com) is a Platform as a Service Provider which uses Amazon Web Services infrastructure for hosting applications and Git as a \nversioning tool. When an application is defined at AppHarbor, a Git repository is created to manage versions of the application's deployment.\nThe Eref application is defined as an application at AppHarbor to create the production repository of the desktop application. The staging version\nof the desktop application is defined by a repository called SEref. The Eref repository at AppHarbor is maintained at the Catmaran piad subscription\nlevel and the SEref repository is maintained at the free Canoe subscription level.  A Main Street Ministries (MSM) account has been created at AppHarbor for deployment of the application. The credentials for this account are:  User name: msmapricot\nEmail: apricot@msmhouston.org\nPassword: <secret>  Only user msmapricot can deploy directly to an application in the MSM account. Any other user needing to deploy to an application in the MSM account must\nbe declared a collaborator on this application. A collaborator is a user associated with a different account established at AppHarbor. For example, my\npersonal account at AppHarbor uses the user name tmhsplb. The user name tmhsplb has been added as a collaborator on the Eref application, thereby\nallowing me to deploy to this application.  The remote configured for Eref in Visual Studio is:  https://msmapricot@appharbor.com/eref.git  This remote is configured from a Windows Git BASH shell by the command  git remote add eref https://msmapricot@appharbor.com/eref.git  After the remote is configured in the Git BASH shell, issuing the command  git push eref master  will deploy the master branch of Eref to AppHarbor as application Eref.  If you reset your password at AppHarbor, the 'git push' command will no longer work from the Git BASH shell. You need to have git prompt you for your\nnew password. To do this on a Windows 10 machine, go to  Control Panel > User Accounts > Credential Manager > Windows Credentials  and remove the AppHarbor entry under Generic Credentials. The next time you push, you will be prompted for your repository password.  An application such as SEref deployed using the free Canoe subscription level at AppHarbor has limitations that make it unsuitable for production\nuse. Under the Canoe subscription, the IIS application pool of application SEref has a 20 minute timeout, which forces SEref to spin up its resources\nagain after each 20 minutes of idle time.  The URL of the Canoe version is  https://eref.apphb.com  The free Yocto version of SQL Server is used as an add-on to the Eref deployment. The Yocto version is free but has a limit of 20MB of storage space,\nwhich is adequate for development purposes.    The remote configured for SEref in Visual Studio is:  https://msmapricot@appharbor.com/seref.git  This remote is configured from a Windows Git BASH shell by the command  git remote add seref https://msmapricot@appharbor.com/seref.git  After the remote is configured in the Git BASH shell, issuing the command  git push seref master  will deploy the master branch of Eref to AppHarbor as application SEref.  The production version of application Eref was created by changing the subsription of application Eref from Canoe to Catamaran. The URL of the production\nversion is still https://eref.apphb.com.  It is possible to use AppHarbor to generate a custom domain name for an application, but this has not been done for the Eref application. The SQL \nServer of the production version of Eref was upgraded from the free Yocto version to the paid uses the Nano version which has a 10GB storage limit. \nThe staging application SEref uses the free Canoe service and the free Canoe version of SQL Server.",
            "title": "AppHarbor"
        },
        {
            "location": "/infrastructure/#jqgrid",
            "text": "Almost every page of the Eref application features a grid produced by the jQuery jqGrid component. It was installed into the Eref project by using\nthe Package Manager command:  PM> Install-Package Triand.jqGrid -Version 4.6.0  There is a collection of  jqGrid Demos  that was very helpful during the development of Eref.",
            "title": "jqGrid"
        },
        {
            "location": "/infrastructure/#log4net",
            "text": "Application logging is handled by Version 2.0.8 of log4net by the Apache Software Foundation. This package was installed using the Visual Studio NuGet\npackage manager. The application log for project Eref is maintained as a database table as described in  this article  describing the AdoNetAppender for log4net. The article includes a script\nfor creating table Log (renamed AppLog in application Eref). The script must be executed as a query in SSMS to create table AppLog in the database.  The application log is configured by the connection string named ErefConnectionString on Web.config. The value of this connection string is overwritten\nwhen the application is deployed to AppHarbor. See the Connection String section of the Database tab.",
            "title": "log4net"
        },
        {
            "location": "/infrastructure/#elmah",
            "text": "Unhandled application errors are caught by ELMAH. Version 2.1.2 of Elamh.Mvc was installed in project Eref by using the Visual Studio NuGet package\nmanager. To see ELMAH in action, modify the URL in the browser address bar to, for example,  eref.apphb.com/Admin/Foo  This will generate an unhandled error because the MVC routing system will not be able to resolve the URL. Then go to  eref.apphb.com/elmah.axd  to see that this error has been caught by ELMAH.  Installation of the Elmah.Mvc package adds the necessary DLL's and makes the necessary changes to Web.config to configure ELMAH for use. By default\nELMAH will write to a database table called ELMAH_Error. The DDL Script definition of this table is found in a  separate download . Download the DDL Script for MS SQL Server from the referenced web page. The script is a .SQL\nfile which may be executed as a query inside SSMS to create table ELMAH_Error.  The ELMAH log is configured by the connection string named ErefConnectionString on Web.config. The value of this connection string is overwritten\nwhen the application is deployed to AppHarbor. See the Connection String section of the Database tab.",
            "title": "ELMAH"
        },
        {
            "location": "/infrastructure/#google-maps",
            "text": "The referral letter generated by Eref includes a static Google Map showing the location of Main Street Ministries. A new copy of this map is generated\neach time a referral letter is requested. The map is generated using the Google Maps static map API. The key for this API is stored in the <appSettings>  section of Web.config under the name GmapKey.",
            "title": "Google Maps"
        },
        {
            "location": "/infrastructure/#mkdocs",
            "text": "This document was created using MkDocs as was the  MkDocs website  itself. MkDocs was installed following the guide\non  this page . An MkDocs document is a static website and can hosted by\nany service that supports static sites. This MkDocs document is hosted by  GitHub Pages . The  Brackets \nopen sourece text editor was used to develop the document on the desktop. An MkDocs document uses HTML Markdown for a desktop development version of a\ndocument. GitHub provides a  cheatsheet for Markdown syntax .  MkDocs provides a built-in preview server which allows the development version to be viewed in a desktop browser at   http://127.0.0.1:8000  When it is time to publish a version of a document, in a Git BASH shell opened on the folder containing the mkdocs.yml file, issue the command  mkdocs build  to expand the Markdown version of the document into an HTML version into the /site folder. After this define a remote called origin for the document:  git remote add origin https://github.com/msmapricot/erefdoc  This command references the pre-created GitHub repository erefdoc. The remote only  needs to be defined once. It will be remembered by the \nGit BASH shell.   In the shell issue the following commands:  git add -A\n\ngit commit -a -m 'Comment on new version of eref document'\n\ngit push --set-upstream origin master  This will push the master branch of the document to the repository identified by the remote called origin. To view the published document go to:  https://msmapricot.github.io/erefdoc/site  It will take several minutes before the changes are available.",
            "title": "MkDocs"
        },
        {
            "location": "/database/",
            "text": "Database\n\n\nEref is a database driven application built using SQL Server technology. In the desktop environment Eref is built using the Sql Server Express database\nengine. In the online environment at AppHarbor a full SQL Server is used. The two versions are compatible with each other with respect to the\ndatabase features used. SQL Server Management Studio 2016 (SSMS) was used to manage both database engines. In the desktop environment, Windows\nAuthentication is used to connect to the Sql Server Express database. In the oline enviroment, SQL Server Authentication is used to connect to the \nSQL Server database.\n\n\nConnection String\n\n\nIn the desktop environment, SSMS was used to create an empty project database by executing the SQL query\n\n\ncreate database ErefDB\n\n\n\nThe Visual Studio Server Explorer (found under the Eref project View menu) was then used to discover the connection string to database ErefDB by creating\na new Data Connection to it and copying the Connection String property of the data connection as the value of the variable SQLSERVER_CONNECTION_STRING in\nthe \n<appSettings>\n section of Web.config. This setting is read programatically by the constructors on IdentityDb.cs and ReferallsDB.cs. See the code\nbase. Getting the value of the connection string programatically eliminates the need to configure\nthe connection string in the usual place, the \n<connectionStrings>\n section of Web.config.\n\n\nThe online version of Eref is hosted as an application at AppHarbor and it uses a database server provided as an add-on. The add-on database server\nincludes a database which serves as the application database, so it is not necessary to create the application database as was done above for the desktop\nversion.\n\n\nThe connection string of the SQL Server instance at AppHarbor is found under the Configuration Variables section for the Eref application. The \nConfiguration Variables section states that the configuration variables should be accessed programatically, since the values may be updated by the\nadd-on provider without notice. An \nAppHarbor knowledge base article\n explains that the\nconnection string is injected as the value of SQLSERVER_CONNECTION_STRING into the \n<appSettings>\n section of Web.config at application\ndeploy time. This injection overwrites the statically configured value.\n\n\nTo discover the value of the connection string in the staging and production environments, the SuperadminController was modified to report the value\nstored in \n<appSettings>\n. Each time the Super Admin logs in, the value will be displayed by view ~/Views/Superadmin/Home.cshtml. Knowing this value \nallows a connection to the Eref database to be made through SSMS using SQL Server Authentication. \n\n\nBoth ELMAH and log4net share the configuration string used by the Eref application. This sharing is accomplished by configurig the connection string\nErefConnectionString on Web.config and setting the connection string alias for the SQL Server add-on at AppHarbor to be ErefConnectionString. When\napplication Eref is deployed, this alias will overwrite the configured value on file Web.config by the value the connection string for the AppHarbor\ndatabase. This is explained in the same knowledge base article referenced above.\n\n\nDatabase Diagram\n\n\n\n\nThe 3 tables in the upper left of the above diagram are created by ASP.NET Identity 2.0 to manage registered users of Eref. The 3 tables are managed by\ntheir own data context which cannot be augmented by additional tables. However, data fields can be added to table \nAspNetUsers\n to connect it to\ntables created in a separate data context. This is what has been done for project Eref. The data fields AgencyID and NowServing have been added to table\n\nAspNetUsers\n to connect it to the 4 tables \nAgencies\n, \nInvitations\n, \nClients\n and \nVisits\n, which are the data tables used to manage Eref\nreferrals. These 4 tables are managed by their own data context.\n\n\nThe NowServing field of the \nAspNetUsers\n table is used to keep track of the client currently being served by an Eref user. The usage of this data\nfield is explained in the Implementation tab.\n\n\nThe 2 data contexts of project Eref are referred to as IdentityDb and ReferralsDB. (See the section Entity Framework Code First of the Infrastructure\ntab.) The technique for establishing a single connection string over 2 data contexts is described in \n\nScott Allen's Pluralsight video\n.\n\n\nThe tables in the diagram used to manage Eref referrals were created using a script file. The technique for creating a script file is\ndescribed in the \nGetting a SQL Script\n section of \nthis article\n. This technique is used to keep\nthe deployd versions of the Eref database in synch with the development version. According to this article, the command\n\n\nPM> update-database -ConfigurationTypeName Eref.DataContexts.ReferralMigrations.Configuration -Script -SourceMigration $InitialDatabase\n\n\n\nwill create a script file necessary to create the tables for Eref referrals using all the migrations applied since the initial migration.\n\n\nManaging Users\n\n\nEref is a role based database application administered by a Superadmin. The Superadmin has the responsibilty of establishing a login account for each\nEref user to prevent a user from specifying his/her own role. Most users will be in the role of Client Advocate, which has been established by the \nSuperadmin. \n\n\nThe Superadmin will be given a user name for a new user together with the agency the user works for. For example, if Mary Atwood who works \nfor the Salvation Army would like to become an Eref Client Advocate under the user name Mary, this request would be presented to the Superadmin user\nat Main Street Ministries. Provided that the user name Mary is not already in use, the Superadmin user would use a private interface to enter Mary\nAtwood in the \nInvitations\n table under UserName Mary with FullName Mary Atwood. Through the private interface the Superadmin would also enter an\nemail address for Mary and select the Salvation Army as the agency that she represents and select Client Advocate as her role. When saved through the\nprivate interface, this will create a record in the \nInvitations\n table which is in effect an invitation for Mary Atwood to register under user name\nMary. \n\n\nThe Superadmin will notify Mary that her account has been created and that she may register for its use using user name Mary, the email address she\nhas provided and a password of her choosing. When Mary registers, the user name and email address she provides will be checked against the\n\nInvitiations\n table. If this pair of identifiers is not found in the \nInvitations\n table, Mary's attempt to register will be rejected. IF they\nare found, a record will be created for her in the \nAspNetUsers\n table using the password she has specified and using the role\nof Client Advocate from the \nInvitations\n table. The AgencyID field of the created record (obtained from the \nInvitations\n table) will point to\nthe record representing the Salvation Army in the \nAgencies\n table. On subsequent visits to Eref, Mary may simply login with the credentials \nestablished by her registration. When logged in she will be recognized as a Client Advocate for the Salvation Army and will see only records of clients\nserved by the Salvation Army.",
            "title": "Database"
        },
        {
            "location": "/database/#database",
            "text": "Eref is a database driven application built using SQL Server technology. In the desktop environment Eref is built using the Sql Server Express database\nengine. In the online environment at AppHarbor a full SQL Server is used. The two versions are compatible with each other with respect to the\ndatabase features used. SQL Server Management Studio 2016 (SSMS) was used to manage both database engines. In the desktop environment, Windows\nAuthentication is used to connect to the Sql Server Express database. In the oline enviroment, SQL Server Authentication is used to connect to the \nSQL Server database.",
            "title": "Database"
        },
        {
            "location": "/database/#connection-string",
            "text": "In the desktop environment, SSMS was used to create an empty project database by executing the SQL query  create database ErefDB  The Visual Studio Server Explorer (found under the Eref project View menu) was then used to discover the connection string to database ErefDB by creating\na new Data Connection to it and copying the Connection String property of the data connection as the value of the variable SQLSERVER_CONNECTION_STRING in\nthe  <appSettings>  section of Web.config. This setting is read programatically by the constructors on IdentityDb.cs and ReferallsDB.cs. See the code\nbase. Getting the value of the connection string programatically eliminates the need to configure\nthe connection string in the usual place, the  <connectionStrings>  section of Web.config.  The online version of Eref is hosted as an application at AppHarbor and it uses a database server provided as an add-on. The add-on database server\nincludes a database which serves as the application database, so it is not necessary to create the application database as was done above for the desktop\nversion.  The connection string of the SQL Server instance at AppHarbor is found under the Configuration Variables section for the Eref application. The \nConfiguration Variables section states that the configuration variables should be accessed programatically, since the values may be updated by the\nadd-on provider without notice. An  AppHarbor knowledge base article  explains that the\nconnection string is injected as the value of SQLSERVER_CONNECTION_STRING into the  <appSettings>  section of Web.config at application\ndeploy time. This injection overwrites the statically configured value.  To discover the value of the connection string in the staging and production environments, the SuperadminController was modified to report the value\nstored in  <appSettings> . Each time the Super Admin logs in, the value will be displayed by view ~/Views/Superadmin/Home.cshtml. Knowing this value \nallows a connection to the Eref database to be made through SSMS using SQL Server Authentication.   Both ELMAH and log4net share the configuration string used by the Eref application. This sharing is accomplished by configurig the connection string\nErefConnectionString on Web.config and setting the connection string alias for the SQL Server add-on at AppHarbor to be ErefConnectionString. When\napplication Eref is deployed, this alias will overwrite the configured value on file Web.config by the value the connection string for the AppHarbor\ndatabase. This is explained in the same knowledge base article referenced above.",
            "title": "Connection String"
        },
        {
            "location": "/database/#database-diagram",
            "text": "The 3 tables in the upper left of the above diagram are created by ASP.NET Identity 2.0 to manage registered users of Eref. The 3 tables are managed by\ntheir own data context which cannot be augmented by additional tables. However, data fields can be added to table  AspNetUsers  to connect it to\ntables created in a separate data context. This is what has been done for project Eref. The data fields AgencyID and NowServing have been added to table AspNetUsers  to connect it to the 4 tables  Agencies ,  Invitations ,  Clients  and  Visits , which are the data tables used to manage Eref\nreferrals. These 4 tables are managed by their own data context.  The NowServing field of the  AspNetUsers  table is used to keep track of the client currently being served by an Eref user. The usage of this data\nfield is explained in the Implementation tab.  The 2 data contexts of project Eref are referred to as IdentityDb and ReferralsDB. (See the section Entity Framework Code First of the Infrastructure\ntab.) The technique for establishing a single connection string over 2 data contexts is described in  Scott Allen's Pluralsight video .  The tables in the diagram used to manage Eref referrals were created using a script file. The technique for creating a script file is\ndescribed in the  Getting a SQL Script  section of  this article . This technique is used to keep\nthe deployd versions of the Eref database in synch with the development version. According to this article, the command  PM> update-database -ConfigurationTypeName Eref.DataContexts.ReferralMigrations.Configuration -Script -SourceMigration $InitialDatabase  will create a script file necessary to create the tables for Eref referrals using all the migrations applied since the initial migration.",
            "title": "Database Diagram"
        },
        {
            "location": "/database/#managing-users",
            "text": "Eref is a role based database application administered by a Superadmin. The Superadmin has the responsibilty of establishing a login account for each\nEref user to prevent a user from specifying his/her own role. Most users will be in the role of Client Advocate, which has been established by the \nSuperadmin.   The Superadmin will be given a user name for a new user together with the agency the user works for. For example, if Mary Atwood who works \nfor the Salvation Army would like to become an Eref Client Advocate under the user name Mary, this request would be presented to the Superadmin user\nat Main Street Ministries. Provided that the user name Mary is not already in use, the Superadmin user would use a private interface to enter Mary\nAtwood in the  Invitations  table under UserName Mary with FullName Mary Atwood. Through the private interface the Superadmin would also enter an\nemail address for Mary and select the Salvation Army as the agency that she represents and select Client Advocate as her role. When saved through the\nprivate interface, this will create a record in the  Invitations  table which is in effect an invitation for Mary Atwood to register under user name\nMary.   The Superadmin will notify Mary that her account has been created and that she may register for its use using user name Mary, the email address she\nhas provided and a password of her choosing. When Mary registers, the user name and email address she provides will be checked against the Invitiations  table. If this pair of identifiers is not found in the  Invitations  table, Mary's attempt to register will be rejected. IF they\nare found, a record will be created for her in the  AspNetUsers  table using the password she has specified and using the role\nof Client Advocate from the  Invitations  table. The AgencyID field of the created record (obtained from the  Invitations  table) will point to\nthe record representing the Salvation Army in the  Agencies  table. On subsequent visits to Eref, Mary may simply login with the credentials \nestablished by her registration. When logged in she will be recognized as a Client Advocate for the Salvation Army and will see only records of clients\nserved by the Salvation Army.",
            "title": "Managing Users"
        },
        {
            "location": "/implementation/",
            "text": "Implementation\n\n\nApplication Eref is implemented as an ASP.NET MVC 4.5 project using Visual Studio 2015 (Community Edition). It uses ASP.NET Identity 2.0 to define a set\nof user roles. Each user role is associated with a separate MVC controller. Controller inheritance is used to share the functionality of a client\neditor across user roles. \n\n\nThe graphical user interface of Eref is built using Bootstrap 3.0.0. Each user role is associated with its own layout file which defines a Bootstrap\nnavbar containing links to the Eref features available to users in the role. The ASP.NET Identity system ensures that a user in a specified role cannot\nvisit any pages outside of those allowed to users in that role.\n\n\nThe source code is the ultimate reference for the implementation.\n\n\nThe Superadmin\n\n\nEref defines a pre-registered superadmin user who has privileges to\n\n\n\n\nadd new agencies\n\n\ncreate new roles\n\n\ninvite new users to register in a pre-determined role\n\n\n\n\nThe credentials for the superadmin are stored in the \n<appSettings>\n section of file Web.config and are retrieved on file Startup.cs.\n\n\nA new user of Eref has to be invited to register by the superadmin. This is done to prevent new users from selecting their role. The superadmin will\ncontact a new user to find out the user name and email address he would like to use to register. The user name and email address will be added to the\n\nInvitations\n table. When the user registers for Eref, he must use the same user name and email that he provided to the superadmin together with\na password of his choosing.\n\n\nRole Controllers\n\n\nThere is an MVC controller defined for each role defined by the superadmin. Each controller defined for a role inherits from ClientManagerController,\nwhich in turn inherits from UsersController. The role controllers generate the views of application Eref. The implementation of each role controller\ndefines methods that are accessible through the menubar defined on the layout file for the role. For example, the AgentController - which implements\nthe Client Advocate role - contains methods Home and OurClients invoked from the menubar defined on file\n\n\n~/Shared/_Agent.cshtml.\n\n\nThis is the layout file for the Client Advocate role. Each view returned by the AgentController includes this layout file, thereby ensuring that a\nuser in the role of Client Advocate will only have access to methods defined by the AgentController.\n\n\nEach other role controllers is implemented the same way: each has a defined layout file that is included in each view returned by the controller.\nThe layout file defines a menubar that specifies the methods that users in the role can execute.\n\n\nThe ClientManagerController\n\n\nThe ClientManagerController implements the editor functionality available to the different roles. Each role controller derives from\nClientManagerController.\n\n\nThe Data Manager\n\n\nAll access to database tables managed by the the ReferrralsDB data context is handled by the DataManager class. The CRUD operations available in each \nrole are defined by the ClientManagerController and implemented by the DataManager.\n\n\nThe UsersController\n\n\nThe UsersController controls access to the ASP.NET Identity tables used to store registered users and the roles they are in. The method\nUsersController.Index is the entry point for an authenticated user. The role an authenticated user is in determines the method the user will be\nredirected to from this entry point.\n\n\njqGrid\n\n\nThe entire implementation of application Eref is structured around instances of jqGrid appearing in MVC Views. Each jqGrid is initially populated\nby a call to an MVC action made through the url property of the grid. For example, the clientsGrid on file AgencyClients.cshtml is initially populated\nby the call\n\n\n\"@Url.Action(\"GetAgencyClients\", \"Agent\")\"\n\n\n\nwhich is the value of the url argument to grid clientsGrid. A grid may have an associated subgrid. The clientsGrid has a subgrid called the\nsupportingDocumentsGrid. A subgrid is populated when a row of its supergrid is selected. This happens through the function which is the value of the\nonSelectRow argument of the supergrid. For example, when a row of grid clientsGrid is selected, the supportingDocumentsGrid is populated by the value of\nthe MVC action call \n\n\n\"@Url.Action(\"GetSupportingDocuments\", \"Agent\")\"\n\n\n\nwhich is the value of the url argument to subgrid supportingDocumentsGrid.\n\n\nEach instance of a jqGride defines a \npager\n. The pager of a jqGrid defines the CRUD operations supported by the grid. Each CRUD operation is\nimplemented by an MVC action of the role controller associated with the grid. \n\n\nInitial population of a grid, grid pagination, grid searching and grid CRUD operations are all supported by server side code.\n\n\nThere is a collection of \njqGrid Demos\n that was very helpful during the development of Eref.\n\n\nNowServing\n\n\nAn important concept in the implementation of Eref is the concept of the client currently being served by a registerd Eref user. When a row in the\nclientsGrid defined on AgencyClients.cshtml is selected, the function that is the value of the onSelectRow argument of the grid is invoked. When the\nfunction is invoked, the value passed to its nowServing argument is the id associated with the client represented by the selected row. The code\nshows that the function is used to populate the subgrid supportingDocumentsGrid through the action call\n\n\n\"@Url.Action(\"GetSupportingDocuments\", \"Agent\")\"\n\n\n\nwhich is the value of the url argument to the subgrid (see the section on the jqGrid). In the source code of AgencyClients.cshtml, the line above\nthis action call is\n\n\npostData: { nowServing: nowServing }\n\n\n\nThe effect of this line is to have the value of the JavaScript variable nowServing be added to the post to method GetSupportingDocuments. Inspecting\nthe definition of this method (found on file ClientManagerController due to controller inheritance) it is seen that the method has an optional\nargument called nowServing. MVC data binding will cause this variable to be bound to the JavaScript variable in the post.\n\n\nThe subsequnet call to SetNowServing (found on file UsersController due to controller inheritance) will cause the NowServing database field in table\n\nAspNetUsers\n of the usr who clicked on the client row in the clientsGrid to receive the value of JavaScript variable nowServing.\n\n\nKnowing which client is being served is necessary when either the\n\n\n  Services for Selected Client\n\n\n\nor the\n\n\n  Letter for Selected Client\n\n\n\nbutton at the bottom of AgencyClients.cshtml is clicked. Tracing what happens is left as an exercise to the reader.\n\n\nVisits\n\n\nIn most cases a client will visit an agency once and only once. But there will be times when a client will pay a return visit to an ageny for help\nwith additional services. For this reason there is a one-to-many relationship between the \nClients\n table and the \nVisits\n table. The Client_Id\nfield of the \nVisits\n table is a foreign key defined by the Id field of table \nClients\n.\n\n\nThe first time a client visits an agency, a record corresponding to this visit is created in the \nVisits\n table. This happens by the call to method \nAddClientVisit in method GetClientVisits of the DataManager. The parameter nowServing of this method will be set to the Id of the client being served.\n\n\nMethod AddClientVisit returns a Visit entity which has its Id field set (as a side effect) to the index of the visit which has been inserted into the \n\nVisits\n table. A \ncomment\n appears at this point \nin the code to highlight this side effect. When method AddClientVisit returns control to method GetClientVisits, the visit entity it returns has its Id \nproperty copied to a VisitViewModel object, vvm, being constructed:\n\n\nvvm.Id = visit.Id\n\n\n\nThe same \ncomment\n is repeated at this point in\nmethod GetClientVisits.\n\n\nWithout the setting to the VisitViewModel made above, a visit being selected from the table on Visits.cshtml would passs 0 as the value of nowVisiting\nwhen the visit's row is selected:\n\n\nonSelectRow: function (nowVisiting)\n\n\n\nWith the setting to the VisitViewModel made above, the Id of the selected row will be passed as the value of nowVisiting which will ultimately point\nback to the identity of the client being served and will allow the Supporting Documents subgrid on Visits.cshtml to be populated.\n\n\nReferral Letters\n\n\nThe referral letter for a client is generated from data collected in the \nClients\n and \nVisits\n tables. (See the database tab.) Each client is\nrepresented by a single\nrecord in the \nClients\n table. In addition to a client's name, the \nClients\n table contains a boolean data field for each supporting document\nthe client has presented to the Client Advocate that he/she is working with. There is a text data field called Notes in the \nClients\n table that \nis used to collect information about a client not captured by any other data field. If a client has dependents, each dependent will be entered\ninto the \nClients\n table with a pointer back to the client. This is done through the Family data field in the \nClients\n table. The Family\ndata field of the head of a household will be set to 0. The Family data field of any dependent of a client will be set to the client Id of the client\nwho is the head of the household.\n\n\nThe \nVisits\n table is related to the \nClients\n table by the foreign key stored in its Id field. The table is used to collect service requests for \na client. Each record in the \nVisits\n table is related to a client in the \nClients\n table through the Id foreign key and stores the service requests\nmade by a client on a particuar date. \n\n\nA Client Advocate with an understanding of the Operation ID identification requirements will be able to determine whether the supporting documents\npresented by a client are sufficient for the services a client seeks during a given visit. If the supporting documents are sufficient, the Client\nAdvocate may use Eref to generate a referral letter that will list the supporting documents presented together with the services requested by a client.\nIf the supporting documents are clearly not sufficient for the services sought, the Client Advocate may work with the client to obtain the documents\nrequired before sending him/her to Operation ID. If there is a question about the sufficiency of the supporting documents, the Client Advocate may\ngenerate a referral letter and send the client to Operation ID where a determination will be made. A future release of Eref will use a built in set\nof rules to help determine the sufficiency of documents presented in support of identification services.\n\n\nWhen a client is entered into the \nClients\n table, a unique 6 letter token (example: DSQMNJ) will be stored with the client's record in the\n\nClients\n table. This token will be included in the referral letter as means of uniquely identifying a client in case the client's name is not\nsufficient. The token is also an anti-forgery safeguard. Any attempt to forge a referral letter will be defeated by the requirement of containing\na 6 letter token that matches the token associated with a client in the \nClients\n table.",
            "title": "Implementation"
        },
        {
            "location": "/implementation/#implementation",
            "text": "Application Eref is implemented as an ASP.NET MVC 4.5 project using Visual Studio 2015 (Community Edition). It uses ASP.NET Identity 2.0 to define a set\nof user roles. Each user role is associated with a separate MVC controller. Controller inheritance is used to share the functionality of a client\neditor across user roles.   The graphical user interface of Eref is built using Bootstrap 3.0.0. Each user role is associated with its own layout file which defines a Bootstrap\nnavbar containing links to the Eref features available to users in the role. The ASP.NET Identity system ensures that a user in a specified role cannot\nvisit any pages outside of those allowed to users in that role.  The source code is the ultimate reference for the implementation.",
            "title": "Implementation"
        },
        {
            "location": "/implementation/#the-superadmin",
            "text": "Eref defines a pre-registered superadmin user who has privileges to   add new agencies  create new roles  invite new users to register in a pre-determined role   The credentials for the superadmin are stored in the  <appSettings>  section of file Web.config and are retrieved on file Startup.cs.  A new user of Eref has to be invited to register by the superadmin. This is done to prevent new users from selecting their role. The superadmin will\ncontact a new user to find out the user name and email address he would like to use to register. The user name and email address will be added to the Invitations  table. When the user registers for Eref, he must use the same user name and email that he provided to the superadmin together with\na password of his choosing.",
            "title": "The Superadmin"
        },
        {
            "location": "/implementation/#role-controllers",
            "text": "There is an MVC controller defined for each role defined by the superadmin. Each controller defined for a role inherits from ClientManagerController,\nwhich in turn inherits from UsersController. The role controllers generate the views of application Eref. The implementation of each role controller\ndefines methods that are accessible through the menubar defined on the layout file for the role. For example, the AgentController - which implements\nthe Client Advocate role - contains methods Home and OurClients invoked from the menubar defined on file  ~/Shared/_Agent.cshtml.  This is the layout file for the Client Advocate role. Each view returned by the AgentController includes this layout file, thereby ensuring that a\nuser in the role of Client Advocate will only have access to methods defined by the AgentController.  Each other role controllers is implemented the same way: each has a defined layout file that is included in each view returned by the controller.\nThe layout file defines a menubar that specifies the methods that users in the role can execute.",
            "title": "Role Controllers"
        },
        {
            "location": "/implementation/#the-clientmanagercontroller",
            "text": "The ClientManagerController implements the editor functionality available to the different roles. Each role controller derives from\nClientManagerController.",
            "title": "The ClientManagerController"
        },
        {
            "location": "/implementation/#the-data-manager",
            "text": "All access to database tables managed by the the ReferrralsDB data context is handled by the DataManager class. The CRUD operations available in each \nrole are defined by the ClientManagerController and implemented by the DataManager.",
            "title": "The Data Manager"
        },
        {
            "location": "/implementation/#the-userscontroller",
            "text": "The UsersController controls access to the ASP.NET Identity tables used to store registered users and the roles they are in. The method\nUsersController.Index is the entry point for an authenticated user. The role an authenticated user is in determines the method the user will be\nredirected to from this entry point.",
            "title": "The UsersController"
        },
        {
            "location": "/implementation/#jqgrid",
            "text": "The entire implementation of application Eref is structured around instances of jqGrid appearing in MVC Views. Each jqGrid is initially populated\nby a call to an MVC action made through the url property of the grid. For example, the clientsGrid on file AgencyClients.cshtml is initially populated\nby the call  \"@Url.Action(\"GetAgencyClients\", \"Agent\")\"  which is the value of the url argument to grid clientsGrid. A grid may have an associated subgrid. The clientsGrid has a subgrid called the\nsupportingDocumentsGrid. A subgrid is populated when a row of its supergrid is selected. This happens through the function which is the value of the\nonSelectRow argument of the supergrid. For example, when a row of grid clientsGrid is selected, the supportingDocumentsGrid is populated by the value of\nthe MVC action call   \"@Url.Action(\"GetSupportingDocuments\", \"Agent\")\"  which is the value of the url argument to subgrid supportingDocumentsGrid.  Each instance of a jqGride defines a  pager . The pager of a jqGrid defines the CRUD operations supported by the grid. Each CRUD operation is\nimplemented by an MVC action of the role controller associated with the grid.   Initial population of a grid, grid pagination, grid searching and grid CRUD operations are all supported by server side code.  There is a collection of  jqGrid Demos  that was very helpful during the development of Eref.",
            "title": "jqGrid"
        },
        {
            "location": "/implementation/#nowserving",
            "text": "An important concept in the implementation of Eref is the concept of the client currently being served by a registerd Eref user. When a row in the\nclientsGrid defined on AgencyClients.cshtml is selected, the function that is the value of the onSelectRow argument of the grid is invoked. When the\nfunction is invoked, the value passed to its nowServing argument is the id associated with the client represented by the selected row. The code\nshows that the function is used to populate the subgrid supportingDocumentsGrid through the action call  \"@Url.Action(\"GetSupportingDocuments\", \"Agent\")\"  which is the value of the url argument to the subgrid (see the section on the jqGrid). In the source code of AgencyClients.cshtml, the line above\nthis action call is  postData: { nowServing: nowServing }  The effect of this line is to have the value of the JavaScript variable nowServing be added to the post to method GetSupportingDocuments. Inspecting\nthe definition of this method (found on file ClientManagerController due to controller inheritance) it is seen that the method has an optional\nargument called nowServing. MVC data binding will cause this variable to be bound to the JavaScript variable in the post.  The subsequnet call to SetNowServing (found on file UsersController due to controller inheritance) will cause the NowServing database field in table AspNetUsers  of the usr who clicked on the client row in the clientsGrid to receive the value of JavaScript variable nowServing.  Knowing which client is being served is necessary when either the    Services for Selected Client  or the    Letter for Selected Client  button at the bottom of AgencyClients.cshtml is clicked. Tracing what happens is left as an exercise to the reader.",
            "title": "NowServing"
        },
        {
            "location": "/implementation/#visits",
            "text": "In most cases a client will visit an agency once and only once. But there will be times when a client will pay a return visit to an ageny for help\nwith additional services. For this reason there is a one-to-many relationship between the  Clients  table and the  Visits  table. The Client_Id\nfield of the  Visits  table is a foreign key defined by the Id field of table  Clients .  The first time a client visits an agency, a record corresponding to this visit is created in the  Visits  table. This happens by the call to method \nAddClientVisit in method GetClientVisits of the DataManager. The parameter nowServing of this method will be set to the Id of the client being served.  Method AddClientVisit returns a Visit entity which has its Id field set (as a side effect) to the index of the visit which has been inserted into the  Visits  table. A  comment  appears at this point \nin the code to highlight this side effect. When method AddClientVisit returns control to method GetClientVisits, the visit entity it returns has its Id \nproperty copied to a VisitViewModel object, vvm, being constructed:  vvm.Id = visit.Id  The same  comment  is repeated at this point in\nmethod GetClientVisits.  Without the setting to the VisitViewModel made above, a visit being selected from the table on Visits.cshtml would passs 0 as the value of nowVisiting\nwhen the visit's row is selected:  onSelectRow: function (nowVisiting)  With the setting to the VisitViewModel made above, the Id of the selected row will be passed as the value of nowVisiting which will ultimately point\nback to the identity of the client being served and will allow the Supporting Documents subgrid on Visits.cshtml to be populated.",
            "title": "Visits"
        },
        {
            "location": "/implementation/#referral-letters",
            "text": "The referral letter for a client is generated from data collected in the  Clients  and  Visits  tables. (See the database tab.) Each client is\nrepresented by a single\nrecord in the  Clients  table. In addition to a client's name, the  Clients  table contains a boolean data field for each supporting document\nthe client has presented to the Client Advocate that he/she is working with. There is a text data field called Notes in the  Clients  table that \nis used to collect information about a client not captured by any other data field. If a client has dependents, each dependent will be entered\ninto the  Clients  table with a pointer back to the client. This is done through the Family data field in the  Clients  table. The Family\ndata field of the head of a household will be set to 0. The Family data field of any dependent of a client will be set to the client Id of the client\nwho is the head of the household.  The  Visits  table is related to the  Clients  table by the foreign key stored in its Id field. The table is used to collect service requests for \na client. Each record in the  Visits  table is related to a client in the  Clients  table through the Id foreign key and stores the service requests\nmade by a client on a particuar date.   A Client Advocate with an understanding of the Operation ID identification requirements will be able to determine whether the supporting documents\npresented by a client are sufficient for the services a client seeks during a given visit. If the supporting documents are sufficient, the Client\nAdvocate may use Eref to generate a referral letter that will list the supporting documents presented together with the services requested by a client.\nIf the supporting documents are clearly not sufficient for the services sought, the Client Advocate may work with the client to obtain the documents\nrequired before sending him/her to Operation ID. If there is a question about the sufficiency of the supporting documents, the Client Advocate may\ngenerate a referral letter and send the client to Operation ID where a determination will be made. A future release of Eref will use a built in set\nof rules to help determine the sufficiency of documents presented in support of identification services.  When a client is entered into the  Clients  table, a unique 6 letter token (example: DSQMNJ) will be stored with the client's record in the Clients  table. This token will be included in the referral letter as means of uniquely identifying a client in case the client's name is not\nsufficient. The token is also an anti-forgery safeguard. Any attempt to forge a referral letter will be defeated by the requirement of containing\na 6 letter token that matches the token associated with a client in the  Clients  table.",
            "title": "Referral Letters"
        }
    ]
}